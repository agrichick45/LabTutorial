---
title: "Tutorial"
author: "Mandy Liesch"
date: "2025-06-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


```

Load the required packages

```{r, include=FALSE}
library(tigris)
library(tidyverse)
library(terra)
library(tidyterra)
library(gridExtra)
library(ggpubr)

```

# Vector Data

Vector Data is commonly used at its original resolution, like most traditional maps historically. This type of data comes in lines, and dots (or vertexes). These two elements are put together to create polygons, like a boundary of a lake. It can maintain data and create smooth network analysis. The vertexes need to be stored explicitly in the data, and sometimes, can require a lot of data cleaning. Whenever a file is changed, the underlying network (topology) has to be built again. In this case, we are working with polygon vector data that are the county data shapefiles. 

## Shapefiles

The tigris package allows for the downloading of spatial data at several geographic scales, including states and counties (shown here). There are 3233 county polygons and 9 data fields in the intial tigris file. However, the state vector (using State FIPS), narrows the states to ones that are in the Mississippi/Ohio River Basin. We are looking at a 12 state area that make up the bulk of these basins

```{r echo=T, results='hide'}
#Create a vector with the state FIPS that we need to extract. 
states<-c("5", "17", "18", "19", "21", "22", "27","28",  "29", "39", "47", "55")

#Use the tigris package, and get the counties extracted by the state we specificied
#in the states vector
counties_raw <- tigris::counties(states,
  #add the county boundaries
  cb = TRUE,
  #specify the resolution (we don't need the highest one)
  resolution = "500k",
  #Pick the year the county files are extracted
  year = 2019,
  #specify the data type
  class = "sf"
)
```

```{r}
#Check the metadata information
counties_raw 

```

The polygon file has several important attributes, as well as columns of data associated with each county file (shapefile). There are 1091 counties, with 9 different geographic fields. 

Bounding box limits the geographic area. The Geodetic CRS is very important information when we are dealing with spatial data. IF you are combining or layering information, this value must be the same in both sources, or projections will not line up. The NAD83 is very common for US Datasets.  

Columns include the State FIP value and the county FIP values, as well as the combined GEOID, County Name, Area of Land, water and the Geometry attributes. We do not need the extra values, so we can remove all of the extra columns, except for GEOID and the county NAME. 

```{r, results = FALSE}
#Select the columns needed for geographic data
counties <- counties_raw %>%  
  #Choosing the GEOID to pair with datasets and the county Names
  select(GEOID, NAME)

#Convert data file into a spatVector
counties<- vect(counties)

#plot the counties to check the geographic area
plot(counties)

```

When you use the plot function in base R, it will plot every column as a unique plot, in this case, we will get 2 of these plots. Changing the values into a spatvector using the Terra package shows only one shapefile, and removes the geometries as a column. This also allows the setup to use values in ggplot at a later time. 


## Ancillary Data

Most of these shapefiles can be merged with datafiles and spreadsheets to expand and visualize anything with data. A majority of this federally based data is classified by State code (two numbers) and county code (three numbers). These are combined together to create a GEOID (or FIPS).  For example, the State of Wisconsin has a state code of 55, and each county has its own number, Outagamie County, WI, for example, is county 087, giving it an idenity of 55087. 

Almost all federal agencies have large respositories of data that anyone can access, via downloads of spreadsheet files (or .csv) that can be used for mapping with shapefiles. 

[Atlas of Rural Towns (USDA ERS)](https://www.ers.usda.gov/data-products/atlas-of-rural-and-small-town-america): 

[USDA ERS Data](https://www.ers.usda.gov/data-products)

[CDC Wonder](https://wonder.cdc.gov/): 

[National Agricultural Statistics Service](https://quickstats.nass.usda.gov/): 

[Census Bureau](https://www.census.gov/data.html): 

[Bureau of Labor Statistics](https://www.bls.gov/data/):

[NRCS Geospatial Data Gateway](https://datagateway.nrcs.usda.gov/):

## Datafile

For these shapefiles, we are utilizing a .csv file that was curated from the NASS database from the 2017 Agricultural Census for states on the Mississippi River Basin. 

```{r}
#Load the data frame
NASS2017<-read.csv("NASS2017_Snapshot.csv")

#Observe the data
View(NASS2017)

#Make sure that all columns have 5 numbers 
NASS2017$FIPS<-sprintf("%05d", NASS2017$FIPS)

#Check example output
head(NASS2017)

```

There are 1,090 counties in this area, and 27 columns of data involving crop and agricultural production data. 

FIPS: Federal code identifying counties 

Market_Value: Total Agricultural Market Value in the County in dollars

Per_Crop_sales: Percentage of Agricultural Income Generated by Crop Production

Per_Grain_Mark_Val:  Percentage of Agricultural Income Generated by grain crops (Corn, soybean, etc.)

Per_Cotton_Mark_Val:  Percentage of Agricultural Income Generated by cotton

Per_Other_Crop_Mark_Val: Percentage of Agricultural Income Generated by other crops (like oil crops, hops, etc)

Per_Veg_Sale_Mkt_Val: Percentage of Agricultural Income Generated by vegetables (carrots, cabbage, etc)

Per_Fruit_Sales_Mkt_Val: Percentage of Agricultural Income Generated by fruits (melons, cranberries, blueberries, etc)

Per_Nursery_Sales_Val:  Percentage of Agricultural Income Generated by nursery crops

Per_Cut_Tree_Sales_Val:  Percentage of Agricultural Income Generated by cut trees

Per_Ani_Sales_Mark_Val: Percentage of Agricultural Income Generated by Animal Production

Per_Poul_Sales_Mark_Val: Percentage of Agricultural Income Generated by Poultry Production (Turkey, Broilers, Eggs, etc.)

Per_Milk_Sales_Mrk_Val: Percentage of Agricultural Income Generated by Milk and Milk products

Per_Cattle_Sales_Mrk_Val: Percentage of Agricultural Income Generated by live cattle sales

Per_Hog_Sales_Mrk_Val: Percentage of Agricultural Income Generated by hog sales

Per_Sheep_Sales_Mrk_Val: Percentage of Agricultural Income Generated by sheep sales

PER_AQ_SALES: Percentage of Agricultural Income Generated by aquaculture sales

PER_EQ_SALES: Percentage of Agricultural Income Generated by equine sales

PER_SP_AN_SALES: Percentage of Agricultural Income Generated by other animal sales

Per_Cropland_Manure: Percentage of Agricultural Land with Manure application

Cattle_Operations: Number of Cattle Operations in the county

Milk_Operations: Number of Milk Operations in the county

Poul_Total_Oper: Number of Poultry Operations in the county

Hog_Oper: Number of Hog Operations in the county

TOT_SHEEP_Oper: Number of sheep Operations in the county

EQUI_OPER: Number of horse Operations in the county

TOT_AQUA_OPER: Number of Aquaculture Operations in the county

In order to visualize this data, we need to merge this database with the shapefile. 

```{r}
#the counties data and Agricultural Statistics file
ag_data<-merge(counties, NASS2017, 
               #The Counties files is called GEOID
               by.x='GEOID', 
               # The NASS file is merged from the FIPS column
               by.y='FIPS')

#Check the data
ag_data
```

The file is now converted into a Spatvector, in the NAD83 reference system.



### Create a Map

The [tidyterra](https://dieghernan.github.io/tidyterra/reference/ggspatvector.html) package provides functions designed to seamlessly integrate terra objects (like SpatVector) with ggplot2. 

Use the Geom Spatvector function to graph the shapefile. The resulting file should be a blank shapefile. We need to add parameters to the ggplots to actually make meaningful maps. 

```{r}
#cue up a ggplot
ggplot(ag_data) +
  #utilize the geom_spatvector in tidyterra
  geom_spatvector()

```

Add a column to display using the AES fill option

```{r}
crop_plot<-ggplot() +
  #using the dataset, the fill = column can be changed to any of the above columns
  #to display another variable
  geom_spatvector(data=ag_data, 
                  #The fill value is the parameter that AES visualizes
                  aes(fill = Per_Crop_Sales))

#Check the plot
crop_plot

```

Get a new color scheme. [Color schemes](https://ggplot2-book.org/scales-colour.html) can be flexible, and displayed in many different ways. There are a million different color options, but the Viridis Pallette are designed to be perceptually uniform in both colour and when reduced to black and white, and to be perceptible to people with various forms of colour blindness. The data we are looking at today is continuous, not categorical, which is where the c comes from in the scale fill. There are 8 different options in the Viridis pallette. 

```{r}
#Look at the different color options
?scales::pal_viridis

#Create the ggplot
crop_plot<-ggplot() +
  #using the dataset, the fill = column can be changed to any of the above columns
  #to display another variable. I am using the Percent Crop Sales here
  geom_spatvector(data=ag_data, aes(fill = Per_Crop_Sales)) +
  #Change the color scale using the option 
    scale_fill_viridis_c(option = "cividis")

#Check the plot
crop_plot

```

Customize the legend name by adding a name function to the scale fill option. 

```{r}

#Plot the plot with a Legend Name
crop_plot<-ggplot() +
  #using the dataset, the fill = column can be changed to any of the above columns
  #to display another variable
  geom_spatvector(data=ag_data, aes(fill = Per_Crop_Sales)) +
  #Change the color scale using his options
    scale_fill_viridis_c(option = "cividis", 
                         #Customize the Name of the Legend
                         name = "Percent")

#Check the Plot
crop_plot

```

Add a Title and change the theme to center the title and put the legend on the bottom of the plot. There are many different [theme elements](https://ggplot2.tidyverse.org/reference/element.html) available to customize plots. These elements also exist with [legend configurations](https://r-graph-gallery.com/239-custom-layout-legend-ggplot2.html)

```{r}
#Look at the different color options
crop_plot<-ggplot() +
  #using the dataset, the fill = column can be changed to any of the above columns
  #to display another variable
  geom_spatvector(data=ag_data, aes(fill = Per_Crop_Sales)) +
  #Change the color scale using his options
    scale_fill_viridis_c(option = "cividis", 
                         #Customize the Name of the Legend
                         name = "Percent") +
  #Add a title
  ggtitle("Percent Sales from Crops") +
  #Use the ggplot theme function and center it using the element text
  theme(plot.title = element_text(hjust=0.5), 
        #And put the legend in the bottom
        legend.position = "right")

#Check the plot
crop_plot

```


### Your Turn! 

Change the display variable to a different column, and then change the color and name! You can scroll up to get the variable names and definitions, or you can use the names(ag_data) to get a list of all of the variables

```{r}
#Look at the legend names
names(ag_data)

#Look at the different color options
?scales::pal_viridis


plot2<-ggplot() +
  #using the dataset, the fill = column can be changed to any of the above columns
  #to display another variable
  geom_spatvector(data=ag_data, aes(fill = Per_Crop_Sales)) +
  #Change the color scale using this options
    scale_fill_viridis_c(option = "cividis", 
                         #Customize the Name of the Legend
                         name = "Percent")  +
  #Customize the title based on your data
  ggtitle("Percent Sales from Crops") +
  #You can put the legend in the center here, or leave it on the left (delete element text)
  #or right ((hjust =1))
  theme(plot.title = element_text(hjust=0.5), 
        #Feel free to move the legend away from the bottom, or hit ?theme for other options
        legend.position = "right")

plot2

```

### Side by Side Plots 

This using the [gridExtra](https://cran.r-project.org/web/packages/gridExtra/vignettes/arrangeGrob.html) package, we can arrange graphs to be side by side into rows or columns. This data is better suited for columns. So we can use the grid.arrange to plot several plots into the same area. 

```{r}
#Using the grid arrange, we can put the two plots together side by side
grid.arrange(crop_plot, plot2, ncol=2)
```


### Side by Side Plots With the Same Legend

If you have data like we do in this NASS dataset that is mostly in percentage (though, we have some count or dollar data). You can extract the legend and turn it into a ggplot figure

```{r}
# Extract the legend. Returns a gtable
leg <- get_legend(crop_plot)

# Convert to a ggplot and print
as_ggplot(leg)

#Remove the legends from the old plots
crop_plot <- crop_plot + theme(legend.position="none")

#Remove the legends from the old plots
plot2 <- plot2 + theme(legend.position="none")

#Create a file with two different plots and the legend into three columns
grid.arrange(crop_plot, plot2, leg, ncol=3, 
             #Customize the widths to allow 
             widths=c(2.3, 2.3, 0.8))
```

### Vector Calculations

You can utilize the data existing in the data frame to create new columns for display as well! We have the total market value, and can use this to multiply by the percent sales to get total market values in the Poultry Industry, and then divide by total producers to get total farm size too! 

```{r}
ag_data$Poultry_Per_Capita = (ag_data$MARKET_VALUE * ag_data$Per_Poul_Sales_Mark_Val) / ag_data$Poul_Total_Oper

Poultry_Per_Capita<-ggplot() +
  #using the dataset, the fill = column can be changed to any of the above columns
  #to display another variable
  geom_spatvector(data=ag_data, aes(fill = Poultry_Per_Capita)) +
  #Change the color scale using this options
    scale_fill_viridis_c(option = "magma", 
                         #Customize the Name of the Legend
                         name = "$")  +
  #Customize the title based on your data
  ggtitle("Per Capita Poultry Profitability") +
  #You can put the legend in the center here, or leave it on the left (delete element text)
  #or right ((hjust =1))
  theme(plot.title = element_text(hjust=0.5), 
        #Feel free to move the legend away from the bottom, or hit ?theme for other options
        legend.position = "right")

Poultry_Per_Capita

```


# Raster Data

Raster data represents information as a grid of tiny squares called pixels. They are super common for use in spatially explicit datasets. Each cell has a position and color and is stored in a matrix. Each layer of maps show one attribute, and they are ideally suited for modeling and analysis. Data can be discrete (like land use), or continuous (like elevation), and it can handle both types very easily. The cell size determines resolution for the data. Size of rasters are variable, and it is difficult to establish linear relationships (they get very pixellated). They only can represent one value at a time, and the data can be very large over time and areas. Data also needs to be generalized or interpolated, resulting in data losses and outputs. 

## Raster Processing

These two sections are included for background on processing a raster down to size, since the scale of the FAO dataset is too large to load into github. There are lines further down the document for The soil carbon data was taken from the [FAO GLOSIS v 1.5](https://data.apps.fao.org/glosis/?lang=en) dataset. 

```{r}

# Read the .tif  as a SpatRaster
FAOGlosis<-rast("FAOGlosisv1.5.tif")

FAOGlosis
```
This data is a global spatraster with  18544 x 43200. And the resolution is the WGS84. WGS84 is the global standard, particularly associated with GPS units. with a cell grid size of  0.008333333 x 0.008333333 degrees.  In order to use the data with our existing agricultural dataset, we have to project the raster into the same coordinate reference system as the agricultural shapefile. We do this using project(from, to). Then we crop and mask the function of the global soil map to the extent of the shapefile. This makes sure the area of the global map and clip it to the ag_data1 file. 

```{r}
#Project the ag_data from the NAD 83 into the FAOGlosis WGS84 Dataset project(from, to)
ag_data1<-project(ag_data, FAOGlosis)

#The crop function cuts the FAO glosis map to the ag_data1 area. Mask =  True cuts away the excess. 
#Remove this function and see what it does! 
MS_Area<-crop(FAOGlosis, ag_data1, mask=TRUE)

#Write the raster into the folder it needs to be in.
writeRaster(MS_Area, "clipped_FAO_SOC.tif", overwrite=TRUE)
```

This is where we pick up the project, with the clipped Soil Carbon FAO file using the raster. When we check the projection, we can see the area is down to 2454 x 2007 pixels, that are 1 layer deep, and that we have the WGS84 Coordinate reference system.  

```{r}
MS_area<-rast("clipped_FAO_SOC.tif")

MS_area

```

Plot the blank Spatraster using the ggplot for the MS_area. Unlike the vector files which show empty counties with no values, the raster shows total values of each grid in the default color pallette. 

```{r}
ggplot() +
  geom_spatraster(data=MS_area)

```

Like shapefiles, the ggplot interface using tidyterra can be used to change the colors to a custom pallette. I did this below using a tan to brown continum with the scale fill gradient option. For more information, type ?scale_fill_gradient into the console and learn about gradient colors. When you run the code, you will see that there is a huge variance in the scale, with soil carbon values being over 600 in the swamp values. These comprise very small values of the area, but the influence the color scheme and plot.

```{r}
ggplot() +
  geom_spatraster(data=MS_area) +
  scale_fill_gradient(low = "tan", high = "brown")

```

Change the visual scale using the clamp variable. Everything over the value that you set will display at the value you specify. This code also adds the legend name.

```{r}
#We are setting 125 Mg C/ha as our upper display limit. Change this value up and down 
#and decide if you have a preference 
clamped_raster <- clamp(MS_area, upper = 125, 
                        #values If FALSE values outside the clamping range become NA, 
                        #if TRUE, they get the extreme values. See what it looks like if  Values=False
                        values = TRUE)

ggplot() +
  #change the raster value to the clamped raster
  geom_spatraster(data=clamped_raster) +
  #keep the same color gradient
  scale_fill_gradient(low = "tan", high = "brown", 
                      #add the title to the legend as well
                      name = "Mg C/ha")

```

Add the county shapefile on top so we have some visual boundaries to look at, and add a title and some themes (described above) to the plot, and put the legend at the bottom of the plot. 

```{r}

#Create the SOC Map
SOC_Map<-ggplot() +
  #Use the clamped raster
  geom_spatraster(data=clamped_raster) +
  #keep the same color gradient
  scale_fill_gradient(low = "tan", high = "brown", 
                      #Add the units to the legend
                      name = "Mg C/ha", 
                      #make the NA values transparent, rather than grey for clarity
                      na.value = "transparent") +
  #Add the reprojected spatvector file using a fill value of NA, so you can see the underlying raster values
  geom_spatvector(data=ag_data1, fill=NA) + 
  #Add a title 
  ggtitle("Total Soil Organic Carbon") +
  #center the title and put the legend on the bottom. 
  theme(plot.title = element_text(hjust=0.5), legend.position = "bottom")

#check the map
SOC_Map

```

Use what we learned above to plot a side by side of the raster and vector data in the same figure

```{r}
#Move the crop_plot legend to the bottom so it matches the total SOC plot
crop_plot <- crop_plot + theme(legend.position="bottom")

#Use two upright columns to map the figures together. Try changing ncol to nrow to see the difference.
grid.arrange(crop_plot, SOC_Map, ncol=2)

```

## Your Turn

From the [Unified Soils Map](https://daac.ornl.gov/cgi-bin/dsviewer.pl?ds_id=1242)

1) Load in the Unified Soil Map for Soil Clay into the terra package (Unified_NA_Soil_Map_Topsoil_Clay_Fraction.tif)

2) Check the file Resolution and Projection, are they the same as the clamped_raster we used? What could the different resolutions mean?

3) Project the data to the existing dataset (if need be)

4) crop and mask the soil clay raster to the Mississippi river area

5) Customize and label your raster plot

6) plot it next to the SOC carbon map above

```{r}


```